<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>CGM Simulator: documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="styleSheetFile.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CGM Simulator
   &#160;<span id="projectnumber">1.0.2</span>
   </div>
   <div id="projectbrief">A CGM simulator to demonstrate the BLE CGM profile v1.1</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#overview">Overview of the Library</a><ul><li class="level2"><a href="#mapping">Structure of the Firmware</a></li>
<li class="level2"><a href="#copyright">Copyright Disclaim</a></li>
</ul>
</li>
<li class="level1"><a href="#flowchart">Program Workflow</a></li>
<li class="level1"><a href="#installation">Installation Guideline</a><ul><li class="level2"><a href="#installationcomponents">Components Requirement</a></li>
<li class="level2"><a href="#installationbrief">Brief Installation Guide</a></li>
<li class="level2"><a href="#installationneweriar">Working with IAR Embedded Workbench v8.3 or Newer</a></li>
</ul>
</li>
<li class="level1"><a href="#programming">Procedure for Functional Implementation</a></li>
<li class="level1"><a href="#revision">Revision History</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="overview"></a>
Overview of the Library</h1>
<p>Bluetooth Low Energy (BLE) emerges as part of the <a href="https://www.bluetooth.org/en-us/specification/adopted-specifications">Bluetooth Core Specification V4.0</a>. BLE positions itself as a short range wireless communication protocol that limits power consumption. As part of the power optimization strategy, BLE reduces connection event frequency and packet size.</p>
<p>Packet size reduction becomes possible when both parties in a conversation agree on the same set of rules, including data field, data size, data format ,packet type, behavioral logic etc. These rules are grouped into a unit called service. By implementing the same service on both ends of communication, the overheads to interpret the message are eliminated.</p>
<p>Each service dedicates to an application. For example, the Battery Service defines rules for BLE message carrying the battery information of the device. Whenever BLE expands into new applications, new services are created. The corresponding software needs to be implemented in order to use a new service.</p>
<p>A recently approved BLE service is <a href="https://www.bluetooth.org/docman/handlers/downloaddoc.ashx?doc_id=294794">Continuous Glucose Monitor Service (CGMS)</a>. It standardizes the information exchange rules between a collector and a CGM sensor. Specifically, the CGMS describes the packet format for reporting a glucose measurement, device feature, device status, session start time, sensor runtime and history records. Moreover, it specifies data structure for configuring a CGM (<em>eg.</em>set hyperglycemia alert). As data format and behavioral logic are well defined by the specification, the data collector device and the CGM sensor can be developed independently, provided that both of them conform to the BLE CGMS specification. In such way, the interoperability between CGM sensors and collectors device becomes feasible.</p>
<p>This software library is an implementation of the <a href="https://developer.bluetooth.org/gatt/services/Pages/ServiceViewer.aspx?u=org.bluetooth.service.continuous_glucose_monitoring.xml">Continuous Glucose Monitor Service (CGMS)</a> on the Texas Instrument (TI) BLE stack. The library implements the semantic definition, data structure, application level behavior of a CGMS. At the same time, the compiled program can be run on TI's <a href="https://www.ti.com/product/cc2540">CC254X</a> series of BLE chips.</p>
<p>The application specific CGMS implementation in this library is built on top of the more generic BLE protocol layers, including the Generic Attribute (GATT) layer and the Generic Profile Access (GAP) layer. These layers are implemented in the TI's <a href="http://www.ti.com/tool/ble-stack">BLE stack library</a>, and generally they remain the same for different services.</p>
<h2><a class="anchor" id="mapping"></a>
Structure of the Firmware</h2>
<div class="image">
<img src="stuc_stackfilemapping.png" alt="stuc_stackfilemapping.png"/>
<div class="caption">
Mapping of Functional Blocks to Source Code</div></div>
<p>The CGM sensor simulator is implemented on a single chip CC254X from Texas Instrument (TI). Coming with the chip is the TI operation system, TI Bluetooth LE software stack, and Bluetooth LE profiles.</p>
<p>The above diagram shows the one to one mapping of the software source files with the CGM simulator architecture. The file hierarchy on the right will appear in the workplace of the IAR workbench when opening the project file ($PROJECT_DIR/CC254XDB/CGMSimultor.eww).</p>
<p>Starting from the bottom, <b>HAL</b> (Hardware Abstract Layer) implements the drivers for the peripheral modules on the chip and the circuit board. These files are hardware dependent. Here is the <a href="http://e2e.ti.com/cfs-file/__key/CommunityServer-Discussions-Components-Files/155/8117.HAL-Driver-API.pdf">official manual</a> for the HAL API.</p>
<p><b>LIB</b> (CC2541-BLE-peri.lib) implements the Bluetooth LE stack. This library is supplied in a closed source form by TI. The functions inside the library can be called by the upper layers through the exposed APIs defined under <b>INCLUDE</b> (exposed APIs). An official TI BLE stack API manual is host <a href="http://ideafind.cn/api/BLE_API_Guide_main.htm">here</a>.</p>
<p><b>PROFILES</b> configure those services that the current Bluetooth LE device supports. In the CGM simulator, the profile consists of CGM service (<a class="el" href="cgmservice_8c.html" title="This file contains the CGM sample service for use with the CGM sample application. ">cgmservice.c</a>), Bond Management Service (gapbondmgr.c), Battery Service etc. These files define the characteristics to be included in the service. The implementation of service should be in compliant with the BLE service specifications. The current CGM simulator software emphasizes the implementation of the CGM profile.</p>
<p><b>APP</b> (application layer) folder contains implementation of the behavioral logic behind each of those characteristics defined in the profile. They surround the CGM sensor functions, such as sampling the glucose estimate values, setting the session start time, storing glucose measurement records and later retrieving them via record access control point (RACP).</p>
<p><b>OSAL</b> (OS abstraction layer) is the quasi-realtime operation system that coordinates micro-controller resource among different layers. Additionally, it provides mechanism to pass information among layers asynchronously. An account for the TI OSAL API can be found <a href="http://e2e.ti.com/cfs-file/__key/CommunityServer-Discussions-Components-Files/158/0184.OSAL-API.pdf">here</a>.</p>
<h2><a class="anchor" id="copyright"></a>
Copyright Disclaim</h2>
<p>Please note that the portion of BLE stack source code and library provided by TI is protected by <a class="el" href="tilicense.html">Texas Instruments Incorporated Software License</a> . In brief, modification or redistribution of the TI code is legitimate only when the code is used with a TI chip. For this reason, the TI licensed code is not host in this repository, user needs to download then <a href="http://www.ti.com/tool/ble-stack">here</a> and follow the instructions in <a class="el" href="index.html#installation">Installation Guideline</a> , before the CGMS application can be compiled.</p>
<p>For application layer code ($PROJECT_DIR/Source/), they are created and licensed by the Center for Global eHealth Innovation. <a class="el" href="mitlicense.html">The MIT License</a> applies to this portion of the code, which allows the user to modified, redistribute and relicense the software.</p>
<h1><a class="anchor" id="flowchart"></a>
Program Workflow</h1>
<p>In this section, the five fundamental operations of the CGMS are introduced. Please clink onto the related link for detailed information.</p>
<p><a class="el" href="workflowdiagram.html#workflowracp">Record Access Control Point (RACP)</a> <br/>
 <a class="el" href="workflowdiagram.html#workflowcocp">CGM Specific Operation Control Point (COCP)</a> <br/>
 <a class="el" href="workflowdiagram.html#workflowread">Characteristic Read</a> <br/>
 <a class="el" href="workflowdiagram.html#workflowwrite">Characteristic Write</a> <br/>
 <a class="el" href="workflowdiagram.html#workflowupdate">Glucose Measurement Update</a> <br/>
</p>
<h1><a class="anchor" id="installation"></a>
Installation Guideline</h1>
<p>In this section, a step by step guide for software installation is presented.</p>
<h2><a class="anchor" id="installationcomponents"></a>
Components Requirement</h2>
<table class="doxtable">
<tr>
<th align="center">Components</th><th align="center">Description</th><th align="center">External Link  </th></tr>
<tr>
<td align="center">TI CC2541 Mini Development Kit</td><td align="center">The hardware platform to load the compile firmware for demonstration. This kit is sufficient in developing BLE embedded software.</td><td align="center"><a href="http://www.ti.com/tool/cc2541dk-mini">Link</a> </td></tr>
<tr>
<td align="center">TI CC2540 Mini Development Kit (Optional)</td><td align="center">A similar BLE development hardware kit as CC2541 Mini Development Kit. However, the CC2541 chip has lower power consumption but higher transmission speed.</td><td align="center"><a href="http://www.ti.com/tool/cc2540dk-mini">Link</a> </td></tr>
<tr>
<td align="center">TI BLE Stack</td><td align="center">The software kit provided by TI. The stack consists of software libraries for the CC2541MiniDK, including hardware configuration files, a quasi-OS, BLE stack libraries and some application projects.</td><td align="center"><a href="http://www.ti.com/tool/ble-stack">Link</a> </td></tr>
<tr>
<td align="center">IAR Embedded Workbench for 8051 v8.20.2</td><td align="center">An IDE for embedded software development. It provides the emebedded C code compilation tool chain. This version is recommended because of official support from TI and our CGM service was developped in IAR v8.20.2. Newer version of IAR Embedded Workbench is available from the IAR website, but the project needed to be configured to work with newer version of IAR (<a class="el" href="index.html#installationneweriar">Working with IAR Embedded Workbench v8.3 or Newer</a> see here).</td><td align="center"><a href="http://supp.iar.com/Download/SW/?item=EW8051-EVAL">Link (v9.1)</a> </td></tr>
</table>
<h2><a class="anchor" id="installationbrief"></a>
Brief Installation Guide</h2>
<ol>
<li>
Download and install the IAR Embedded Workbench v8.20.2, TI BLE Stack, TI Smart RF Programmer. For repeatable results, install the TI BLE stack in its default location. (<em>i.e.</em>"C:\\Texas Instruments" for windows users).  </li>
<li>
Clone source code from this repository into a directory (say, $PROJECT_DIR) located at the same level as the BLE stack files (<em>i.e.</em>the "C:\\" if the TI BLE stack is installed to default location).  </li>
<li>
In the IAR IDE, open the project work place file (<em>i.e.</em>$PROJECT_DIR\CC254xDB\CGMSimulator.eww) and press "F7" to compile the project. If the files are in the right place, the project should be able to compile. Otherwise, dependencies needed to be fixed.  </li>
</ol>
<h2><a class="anchor" id="installationneweriar"></a>
Working with IAR Embedded Workbench v8.3 or Newer</h2>
<p>As the project was developed in IAR for 8051 v8.20.2, opening the project with newer IDEs will raise compatibility issues.</p>
<p>First of all, the IDE will prompt to convert the project files into newer versions (<a class="el" href="installationprocedure.html#pic_convert">figure</a>). Click "yes" to confirm the conversion. The project configuration will be updated to the newer IDE.</p>
<p>The second issue occurs when the project is compiled. The console ouptut an error stating "Error[e16]: Segment ISTACK (size: 0xc0 align: 0) is too long for segment definition. At least 0xe more bytes needed." (<a class="el" href="installationprocedure.html#pic_compile">figure</a>). To fix the problem, remove the "_NR_OF_VIRTUAL_REGISTERS" from the linker file (<em>i.e.</em>"C:\\Texas Instruments\\BLE-CC254x-1.4.0\\Projects\\ble\\common\\cc2540\\ti_51ew_cc2540b.xcl", if the BLE stack files are installed in the default location), the example code is highted in <a class="el" href="installationprocedure.html#pic_linkrepair">this figure</a>.</p>
<p>Tackling the above two issues should allow code compilation.</p>
<h1><a class="anchor" id="programming"></a>
Procedure for Functional Implementation</h1>
<p>Implementing an application level function on the current software generally involves three steps. In the following instructions, the implementation of a set hyperglycemia alert function over the CGM Specific Operation Control Point (COCP) Characteristic will be used as an example. Set hyperglycemia alert registers the alert threshold with the CGM sensor through a write command to COCP value. </p>
<ol>
<li>
<p class="startli"><b>Create a pathway from lower GATT request to the application layer callback function.</b></p>
<p>When the controller writes/reads a value to/from a characteristic, the write/read request will first arrive the CGM_WriteAttrCB / CGM_ReadAttrCBfunctions, respectively. The write/read call back functions relay the request to the application level callback function (cgmservice_cb).</p>
<p>A majority of the processing logic should be done inside the cgmservice_cb function, depending on the input request type and request content. By creating a pathway between the GATT and the app level function, it is required to add in a case for the new command in the callback function and the subsequent processing logic.</p>
<p>In the case of set hyper alert threshold, the write request to COCP exists in the cgmservice_cb as, </p>
<pre class="fragment">switch (event)
    {
    case CGM_CTL_PNT_CMD:
            {
            cgmCtlPntMsg_t* msgPtr;
            msgPtr = (cgmCtlPntMsg_t *)osal_msg_allocate( sizeof(cgmCtlPntMsg_t) );
            if ( msgPtr )
            {
            msgPtr-&gt;hdr.event = CTL_PNT_MSG;
            msgPtr-&gt;len = len;
            osal_memcpy(msgPtr-&gt;data, valueP, len);
            osal_msg_send( cgmTaskId, (uint8 *)msgPtr );
            }
            }
    break;
    }
</pre><p>As we see that the callback sends out an OS message to place a COCP event processing request. As the logic behind COCP command can be potentially large, it is better to leverage the task scheduler of the TI OS to guarantee that time critical tasks have a chance to access the MCU.</p>
<p>Periodically, the function cgm_ProcessOSALMsg will be called by the OS to process pending messages. An excerpt of the function is shown below, and it invokes the cgmProcessingCtlPntMsg to process the message. </p>
<pre class="fragment">static void cgm_ProcessOSALMsg( osal_event_hdr_t *pMsg )
    {
        switch ( pMsg-&gt;event )
        {
        case CTL_PNT_MSG:// Receive CGMCP write message from the lower GATT layer
            cgmProcessCtlPntMsg( (cgmCtlPntMsg_t *) pMsg);
            break;
        }
    }
</pre><p>Now the message reaches the cgmProcessCtlPntMsg, which provides logic to process the received COCP command. In the function, a switch statement is present, with each case processes a specific op-code. By adding a case corresponding to the set hyper alert op-code, the pathway between GATT and upper processing app is created.</p>
<pre class="fragment">    switch(opcode)
    {   \/\/Implement the set/get communication interval        
        ....
        case  CGM_SPEC_OP_SET_ALERT_HIGH:       
        \/\*Application logic for processing the set command goes here\*\/ 
        break;
        ....
    }
</pre><p class="endli"></p>
</li>
<li>
<p class="startli"><b>Implement the application level logic.</b></p>
<p>Starting from cgmProcessCtlPntMsg, the logic is strictly confined within the application layer, which means that it is written into the <a class="el" href="cgm_8c.html" title="This file contains the CGM sensor simulator application for use with the CC2540 Bluetooth Low Energy ...">cgm.c</a> file. In the example of setting hyper alert threshold, the implementation can be as follows, </p>
<pre class="fragment">    switch(opcode)
    {
        ....    
        case  CGM_SPEC_OP_SET_ALERT_HYPER:
        \/\/Get the input value
        operand=pMsg-&gt;data+1;
        operand_len=pMsg-&gt;len-1;
        \/\/Set the local variable
        cgmHyperThreshold=BUILD_UINT16(operand[0],operand[1]);
        \/\/Prepare the response message
        ropcode=CGM_SPEC_OP_RESP_CODE;
        roperand[0]=opcode;
        roperand[1]=CGM_SPEC_OP_RESP_SUCCESS;
        roperand_len=2;
        break;
        ....
    }
</pre><p>In the above code segment, the operand within the COCP write request is extracted. Afterwards, the local variable storing hyperglycemia alert threshold is set with the input value. There are associated logic added in the glucose reporting function, which sets the hyperglycemia alert flag when the most current glucose estimate exceeds the threshold; but it is trivial and outside the scope of this instruction.</p>
<p class="endli">It worths mentioning that the above code is for demonstration purpose, it is not yet perfect. A possible improvement is testing the input threshold value before storing it into a local variable. The details are up to the implementation of the glucose monitor.  </p>
</li>
<li>
<p class="startli"><b>Feeding the process result back to GATT layer</b></p>
<p>After the internal variable is updated with the input threshold value associated with the COCP command, collector needs to be informed about the operation result, as required by the CGMS specification. The method of result feedback needs to be an indication to the COCP characteristic.</p>
<p>In the last few lines of the previous code segment, the operation result report is being prepared. Response op-code is being set, and the response operand is loaded with a result value.</p>
<p>Lastly, the prepared response is fed into a function called cgmCtlPntResponse. </p>
<pre class="fragment">static void cgmCtlPntResponse(uint8 opcode, uint8 * roperand, uint8 roperand_len)
{
    cgmCtlPntRsp.value[0]=opcode;
    cgmCtlPntRsp.len=1+roperand_len;
    osal_memcpy(cgmCtlPntRsp.value+1,roperand, roperand_len);
    CGM_CtlPntIndicate(gapConnHandle, &amp;cgmCtlPntRsp, cgmTaskId);
}
</pre><p>The cgmCtlPntResponse sends out an indication to the COCP characteristic through the GATT layer.</p>
<p class="endli">Up to this point, the 3-step procedure of adding an application function has been walked through. Other functions can be implemented in a similar manner.  </p>
</li>
</ol>
<p>The above is a simplified version of the development process should help potential developers get up to speed quickly. For a deeper understanding on software development on CC254x, the following document are recomended,</p>
<ul>
<li>
<a href="http://www.ti.com/lit/ug/swru271f/swru271f.pdf">TI BLE Software Developer's Guide</a> </li>
<li>
<a href="http://www.ti.com/lit/ug/swru297c/swru297c.pdf">TI BLE Sample Application Guide</a> </li>
</ul>
<h1><a class="anchor" id="revision"></a>
Revision History</h1>
<ul>
<li>
2015-03-24 <ul>
<li>
Implemented RACP Delete Function. </li>
<li>
Implemented E2E-CRC data integrity check. </li>
<li>
Implemented CGMCP alert configuration including: patient defined high/low glucose value alert; rate of increase/decrease alert; hyperglycemia/hypoglycemia alert; device alert reset.  </li>
<li>
Implemented CGMCP support for calibration procedure. </li>
<li>
Updated documentation: grouping programming entities into <a href="modules.html">modules</a> for easy navigation.  </li>
<li>
Updated documentation: adding links to TI official document. </li>
<li>
Updated documentation: deleted the future implementation session.  </li>
</ul>
</li>
<li>
2015-02-20 Initial compilation of the CGM Sim library </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Mar 25 2015 11:39:13 for CGM Simulator by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
